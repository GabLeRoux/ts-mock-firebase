import { MockCollection, MockDatabase } from '..';
import { createFirebaseNamespace } from '../../app';
import { MockCollectionReference } from '../MockCollectionReference';
import MockDocumentReference from '../MockDocumentReference';

const firebase = createFirebaseNamespace();
const firestore = firebase.initializeApp({}).firestore();

/* tslint:disable:no-big-function no-identical-functions */
describe('CollectionReferenceMock', () => {
  describe('References', () => {
    it('doc() returns a document by id', () => {
      const collection = new MockCollectionReference(firestore, 'test', null);
      firestore.mocker.reset();
      firestore.mocker.setCollection(collection);

      const document = new MockDocumentReference(firestore, 'doc', collection);
      collection.mocker.setDoc(document);

      expect(collection.doc('doc')).toBe(document);
    });

    it('doc() call without an id will return document reference with autogenerated id', () => {
      const collection = new MockCollectionReference(firestore, 'test', null);
      firestore.mocker.reset();
      firestore.mocker.setCollection(collection);

      const document = new MockDocumentReference(firestore, 'doc', collection);
      collection.mocker.setDoc(document);

      expect(collection.doc().id).toBeDefined();
    });
  });

  describe('add()', () => {
    it('will create a new document with a generated id', async () => {
      firestore.mocker.reset();

      const collection = new MockCollectionReference(firestore, 'test', null);
      firestore.mocker.setCollection(collection);

      const data = {
        test: 'data',
      };

      const document = await collection.add(data);

      expect(document).toBeDefined();
      expect(document.id).toBeDefined();
    });
  });

  const testData = {
    list: {
      docs: {
        c: {
          data: { name: 'c' },
        },
        b: {
          data: { name: 'b' },
        },
        a: {
          data: { name: 'a' },
        },
      },
    },
  };

  const testData2 = {
    list: {
      docs: {
        a: {
          data: { name: 'a' },
        },
        b: {
          data: { name: 'b', key: 'm' },
        },
        c: {
          data: { name: 'c', key: 'm' },
        },
        d: {
          data: { name: 'b' },
        },
      },
    },
  };

  describe('get()', () => {
    it('will get all documents', async () => {
      firestore.mocker.fromMockDatabase(testData);
      const query = await firestore.collection('list').get();

      expect(query).toBeDefined();
      expect(query.size).toBe(3);
      expect(query.docs[0].data()).toEqual({
        name: 'c',
      });
      expect(query.docs[2].data()).toEqual({
        name: 'a',
      });
    });
  });

  describe('limit()', () => {
    it('will return max number of documents defined by limit', async () => {
      firestore.mocker.fromMockDatabase(testData);
      const query = await firestore
        .collection('list')
        .orderBy('name')
        .limit(2)
        .get();

      expect(query).toBeDefined();
      expect(query.size).toBe(2);
      expect(query.docs[0].data()).toEqual({
        name: 'a',
      });
      expect(query.docs[1].data()).toEqual({
        name: 'b',
      });
    });

    it('will give an error if limit is zero or negative', () => {
      firestore.mocker.fromMockDatabase(testData);

      expect(() =>
        firestore
          .collection('list')
          .orderBy('name')
          .limit(-2)
      ).toThrow();

      expect(() =>
        firestore
          .collection('list')
          .orderBy('name')
          .limit(0)
      ).toThrow();
    });
  });

  describe('orderBy()', () => {
    it('will return documents in ascending order as default', async () => {
      firestore.mocker.fromMockDatabase(testData);
      const query = await firestore
        .collection('list')
        .orderBy('name')
        .get();

      expect(query).toBeDefined();
      expect(query.size).toBe(3);
      expect(query.docs[0].data()).toEqual({
        name: 'a',
      });
      expect(query.docs[1].data()).toEqual({
        name: 'b',
      });
      expect(query.docs[2].data()).toEqual({
        name: 'c',
      });
    });

    it('will return documents in ascending order as explicitly', async () => {
      firestore.mocker.fromMockDatabase(testData);
      const query = await firestore
        .collection('list')
        .orderBy('name', 'asc')
        .get();

      expect(query).toBeDefined();
      expect(query.size).toBe(3);
      expect(query.docs[0].data()).toEqual({
        name: 'a',
      });
      expect(query.docs[1].data()).toEqual({
        name: 'b',
      });
      expect(query.docs[2].data()).toEqual({
        name: 'c',
      });
    });

    /* tslint:disable:no-identical-functions */
    it('will return documents in descending order explicitly', async () => {
      firestore.mocker.fromMockDatabase(testData);
      const query = await firestore
        .collection('list')
        .orderBy('name', 'desc')
        .get();

      expect(query).toBeDefined();
      expect(query.size).toBe(3);
      expect(query.docs[0].data()).toEqual({
        name: 'c',
      });
      expect(query.docs[1].data()).toEqual({
        name: 'b',
      });
      expect(query.docs[2].data()).toEqual({
        name: 'a',
      });
    });

    it('will return documents in descending order explicitly', async () => {
      firestore.mocker.fromMockDatabase(testData);
      const query = await firestore
        .collection('list')
        .orderBy('name', 'desc')
        .get();

      expect(query).toBeDefined();
      expect(query.size).toBe(3);
      expect(query.docs[0].data()).toEqual({
        name: 'c',
      });
      expect(query.docs[1].data()).toEqual({
        name: 'b',
      });
      expect(query.docs[2].data()).toEqual({
        name: 'a',
      });
    });

    // TODO ordering by multiple fields
  });

  describe('where()', () => {
    describe('equality', () => {
      it('will return fields with a equal match', async () => {
        firestore.mocker.fromMockDatabase(testData2);
        const query = await firestore
          .collection('list')
          .where('key', '==', 'm')
          .get();

        expect(query).toBeDefined();
        expect(query.size).toBe(2);
        expect(query.docs[0].data()).toEqual({
          name: 'b',
          key: 'm',
        });
        expect(query.docs[1].data()).toEqual({
          name: 'c',
          key: 'm',
        });
      });
    });
    describe('comparization', () => {
      const testData3 = {
        list: {
          docs: {
            a: {
              data: {
                name: 'a',
                value: 5,
              },
            },
            b: {
              data: {
                name: 'b',
                value: 2,
              },
            },
            c: {
              data: {
                name: 'c',
                value: 10,
              },
            },
            d: {
              data: {
                name: 'd',
                value: 20,
              },
            },
          },
        },
      };

      it('will return fields with less than', async () => {
        firestore.mocker.fromMockDatabase(testData3);
        const query = await firestore
          .collection('list')
          .where('value', '<', 10)
          .get();

        expect(query).toBeDefined();
        expect(query.size).toBe(2);
        expect(query.docs[0].data()).toEqual({
          name: 'a',
          value: 5,
        });
        expect(query.docs[1].data()).toEqual({
          name: 'b',
          value: 2,
        });
      });

      it('will return fields with less or equal', async () => {
        firestore.mocker.fromMockDatabase(testData3);
        const query = await firestore
          .collection('list')
          .where('value', '<=', 10)
          .get();

        expect(query).toBeDefined();
        expect(query.size).toBe(3);
        expect(query.docs[0].data()).toEqual({
          name: 'a',
          value: 5,
        });
        expect(query.docs[1].data()).toEqual({
          name: 'b',
          value: 2,
        });
        expect(query.docs[2].data()).toEqual({
          name: 'c',
          value: 10,
        });
      });

      it('will return fields greater than', async () => {
        firestore.mocker.fromMockDatabase(testData3);
        const query = await firestore
          .collection('list')
          .where('value', '>', 10)
          .get();

        expect(query).toBeDefined();
        expect(query.size).toBe(1);
        expect(query.docs[0].data()).toEqual({
          name: 'd',
          value: 20,
        });
      });

      it('will return fields greater or equal', async () => {
        firestore.mocker.fromMockDatabase(testData3);
        const query = await firestore
          .collection('list')
          .where('value', '>=', 10)
          .get();

        expect(query).toBeDefined();
        expect(query.size).toBe(2);
        expect(query.docs[0].data()).toEqual({
          name: 'c',
          value: 10,
        });
        expect(query.docs[1].data()).toEqual({
          name: 'd',
          value: 20,
        });
      });

      it('will return fields between', async () => {
        firestore.mocker.fromMockDatabase(testData3);
        const query = await firestore
          .collection('list')
          .where('value', '>=', 5)
          .where('value', '<', 15)
          .get();

        expect(query).toBeDefined();
        expect(query.size).toBe(2);
        expect(query.docs[0].data()).toEqual({
          name: 'a',
          value: 5,
        });
        expect(query.docs[1].data()).toEqual({
          name: 'c',
          value: 10,
        });
      });
    });

    describe('array checks', () => {
      const testData4 = {
        list: {
          docs: {
            a: {
              data: {
                name: 'a',
                values: [2, 5, 6],
              },
            },
            b: {
              data: {
                name: 'b',
                values: [2, 1, 7],
              },
            },
            c: {
              data: {
                name: 'c',
                values: [1, 5, 8],
              },
            },
          },
        },
      };

      it('is in array match', async () => {
        firestore.mocker.fromMockDatabase(testData4);
        const query = await firestore
          .collection('list')
          .where('values', 'array-contains', 5)
          .get();

        expect(query).toBeDefined();
        expect(query.size).toBe(2);
        expect(query.docs[0].data()).toEqual({
          name: 'a',
          values: [2, 5, 6],
        });
        expect(query.docs[1].data()).toEqual({
          name: 'c',
          values: [1, 5, 8],
        });
      });

      it('is not in array match', async () => {
        firestore.mocker.fromMockDatabase(testData4);
        const query = await firestore
          .collection('list')
          .where('values', 'array-contains', 55)
          .get();

        expect(query).toBeDefined();
        expect(query.size).toBe(0);
      });

      // TODO make it work
      // it('will throw error when matching non array field', () => {
      //   firestore.mocker.fromMockDatabase(testData4);

      //   // tslint:disable-next-line: no-floating-promises
      //   expect(() =>
      //     firestore
      //       .collection('list')
      //       .where('name', 'array-contains', 2)
      //       .get()
      //   ).toThrow();
      // });
    });

    describe('paging with a simple fields', () => {
      const database: MockDatabase = {
        list: {
          docs: {
            a: {
              data: {
                name: 'Blueberry',
                value: 1,
              },
            },
            b: {
              data: {
                name: 'Strowberry',
                value: 2,
              },
            },
            c: {
              data: {
                name: 'Rasberry',
                value: 3,
              },
            },
            d: {
              data: {
                name: 'Cloudberry',
                value: 4,
              },
            },
            e: {
              data: {
                name: 'Lingonberry',
                value: 4,
              },
            },
          },
        },
      };

      it('will limit the result to startAt cursor', async () => {
        firestore.mocker.fromMockDatabase(database);

        const result = await firestore
          .collection('list')
          .orderBy('value')
          .startAt(3)
          .get();

        expect(result.size).toBe(3);
        expect(result.docs[0].data()).toEqual({
          name: 'Rasberry',
          value: 3,
        });
      });

      it('will limit the result to startAfter cursor', async () => {
        firestore.mocker.fromMockDatabase(database);

        const result = await firestore
          .collection('list')
          .orderBy('value')
          .startAfter(2)
          .get();

        expect(result.size).toBe(3);
        expect(result.docs[0].data()).toEqual({
          name: 'Rasberry',
          value: 3,
        });
      });

      it('will limit the result to endBefore cursor', async () => {
        firestore.mocker.fromMockDatabase(database);

        const result = await firestore
          .collection('list')
          .orderBy('value')
          .endBefore(3)
          .get();

        expect(result.size).toBe(2);
        expect(result.docs[0].data()).toEqual({
          name: 'Blueberry',
          value: 1,
        });
      });

      it('will limit the result to endAt cursor', async () => {
        firestore.mocker.fromMockDatabase(database);

        const result = await firestore
          .collection('list')
          .orderBy('value')
          .endAt(3)
          .get();

        expect(result.size).toBe(3);
        expect(result.docs[0].data()).toEqual({
          name: 'Blueberry',
          value: 1,
        });
      });

      it('will limit the result between set start and end cursor', async () => {
        firestore.mocker.fromMockDatabase(database);

        const result = await firestore
          .collection('list')
          .orderBy('value')
          .startAfter(1)
          .endAt(3)
          .get();

        expect(result.size).toBe(2);
        expect(result.docs[0].data()).toEqual({
          name: 'Strowberry',
          value: 2,
        });
        expect(result.docs[1].data()).toEqual({
          name: 'Rasberry',
          value: 3,
        });
      });
    });
  });

  describe('Mocker', () => {
    it('shallow set documents with with shallow set and read them with shallow get', () => {
      const collection = firestore.collection('company');

      collection.mocker.setShallowCollection({
        first: {
          value: 1,
        },
        second: {
          value: 2,
        },
      });
      expect(collection.mocker.getShallowCollection()).toEqual({
        first: {
          value: 1,
        },
        second: {
          value: 2,
        },
      });
    });

    it('shallow set create ', () => {
      const collection = firestore.collection('company');

      collection.mocker.setShallowCollection({
        first: {
          value: 1,
        },
        second: {
          value: 2,
        },
      });
      expect(collection.mocker.getShallowCollection()).toEqual({
        first: {
          value: 1,
        },
        second: {
          value: 2,
        },
      });
    });

    it('save set documents ', () => {
      const collection = firestore.collection('company');

      const mock: MockCollection = {
        docs: {
          first: {
            data: { value: 1 },
          },
          second: {
            data: { value: 2 },
          },
        },
      };
      collection.mocker.load(mock);

      expect(collection.mocker.save()).toEqual(mock);
    });
  });
});
