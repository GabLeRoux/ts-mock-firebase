import { FirebaseAppMock } from 'firebaseApp';
import { FirestoreMock } from 'firestore';
import { CollectionReferenceMock } from 'firestore/CollectionReferenceMock';
import DocumentReferenceMock from 'firestore/DocumentReferenceMock';

describe('CollectionReferenceMock', () => {
  describe('References', () => {
    it('doc() returns a document by id', () => {
      const app = new FirebaseAppMock();
      const firestore = app.firestore() as FirestoreMock;

      const collection = new CollectionReferenceMock(firestore, 'test', null);
      firestore.root.mocker.setCollection(collection);

      const document = new DocumentReferenceMock(firestore, 'doc', collection);
      collection.mocker.setDoc(document);

      expect(collection.doc('doc')).toBe(document);
    });

    it('doc() call without an id will return document reference with autogenerated id', () => {
      const app = new FirebaseAppMock();
      const firestore = app.firestore() as FirestoreMock;

      const collection = new CollectionReferenceMock(firestore, 'test', null);
      firestore.root.mocker.setCollection(collection);

      const document = new DocumentReferenceMock(firestore, 'doc', collection);
      collection.mocker.setDoc(document);

      expect(collection.doc().id).toBeDefined();
    });
  });

  describe('add()', () => {
    it('will create a new document with a generated id', async () => {
      const app = new FirebaseAppMock();
      const firestore = app.firestore() as FirestoreMock;

      const collection = new CollectionReferenceMock(firestore, 'test', null);
      firestore.root.mocker.setCollection(collection);

      const data = {
        test: 'data',
      };

      const document = await collection.add(data);

      expect(document).toBeDefined();
      expect(document.id).toBeDefined();
    });
  });

  const testData = {
    list: {
      docs: {
        c: {
          data: { name: 'c' },
        },
        b: {
          data: { name: 'b' },
        },
        a: {
          data: { name: 'a' },
        },
      },
    },
  };

  describe('get()', () => {
    it('will get all documents', async () => {
      const app = new FirebaseAppMock();
      const firestore = app.firestore() as FirestoreMock;
      firestore.mocker.loadDatabase(testData);
      const query = await firestore.collection('list').get();

      expect(query).toBeDefined();
      expect(query.size).toBe(3);
      expect(query.docs[0].data()).toEqual({
        name: 'c',
      });
      expect(query.docs[2].data()).toEqual({
        name: 'a',
      });
    });
  });

  describe('orderBy()', () => {
    it('will return documents in ascending order as default', async () => {
      const app = new FirebaseAppMock();
      const firestore = app.firestore() as FirestoreMock;
      firestore.mocker.loadDatabase(testData);
      const query = await firestore
        .collection('list')
        .orderBy('name')
        .get();

      expect(query).toBeDefined();
      expect(query.size).toBe(3);
      expect(query.docs[0].data()).toEqual({
        name: 'a',
      });
      expect(query.docs[1].data()).toEqual({
        name: 'b',
      });
      expect(query.docs[2].data()).toEqual({
        name: 'c',
      });
    });
  });

  it('will return documents in ascending order as explicitly', async () => {
    const app = new FirebaseAppMock();
    const firestore = app.firestore() as FirestoreMock;
    firestore.mocker.loadDatabase(testData);
    const query = await firestore
      .collection('list')
      .orderBy('name', 'asc')
      .get();

    expect(query).toBeDefined();
    expect(query.size).toBe(3);
    expect(query.docs[0].data()).toEqual({
      name: 'a',
    });
    expect(query.docs[1].data()).toEqual({
      name: 'b',
    });
    expect(query.docs[2].data()).toEqual({
      name: 'c',
    });
  });

  it('will return documents in descemdomg order explicitly', async () => {
    const app = new FirebaseAppMock();
    const firestore = app.firestore() as FirestoreMock;
    firestore.mocker.loadDatabase(testData);
    const query = await firestore
      .collection('list')
      .orderBy('name', 'desc')
      .get();

    expect(query).toBeDefined();
    expect(query.size).toBe(3);
    expect(query.docs[0].data()).toEqual({
      name: 'c',
    });
    expect(query.docs[1].data()).toEqual({
      name: 'b',
    });
    expect(query.docs[2].data()).toEqual({
      name: 'a',
    });
  });
});
