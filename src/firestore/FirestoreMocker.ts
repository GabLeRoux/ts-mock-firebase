import * as types from '@firebase/firestore-types';

import { FirebaseRulesContext, FirebaseRulesIntepreter } from 'firebase-rules-parser';
import { CollectionObject, MockDatabase, MockTimestampFunction } from '.';
import { Mocker } from '../app';
import { MockCollectionReference } from './MockCollectionReference';
import MockDocumentReference from './MockDocumentReference';
import { MockTimestamp } from './MockTimestamp';

/**
 * Mocker interface to operate in firestore level. User this mocker to setup the initial state of your test case and to
 * define how database wide operations like timestamps are operated.
 *
 * With mocker, you can alter the database state without causing any state change triggerings. You should use it's commands
 * to set up the test case. To read the actual data on tests, is best be done via actual Firestore interfaces.
 */
export interface FirestoreMocker extends Mocker {
  /**
   * Defines a mocked server time used with FieldValue.timestamp. Time can be constant set to property or a function
   * that will return a MockTimestamp value. If the value is not defined, MockFirebase will generate a timestamp from
   * current machine time.
   *
   * @type {(MockTimestamp | MockTimestampFunction)}
   * @memberof FirestoreMocker
   */
  serverTime?: MockTimestamp | MockTimestampFunction; // TODO default value

  /**
   * Load the whole database from MockDatabase -object
   *
   * @param {MockDatabase} database Datbase model
   * @memberof FirestoreMocker
   */
  fromMockDatabase(database: MockDatabase): void;
  /**
   * Create a copy of the whole database
   *
   * @returns {MockDatabase}
   * @memberof FirestoreMocker
   */
  toMockDatabase(): MockDatabase;
  /**
   * Read the database state from a json string
   * @param json Json string containing a json object that follows MockDatabase's type
   */
  fromJson(json: string): void;
  /**
   * Save current database state into a json string
   */
  toJson(): string;

  /**
   * get a collection by path
   *
   * @param {string} path Path to a collection
   * @returns {MockCollectionReference}
   * @memberof FirestoreMocker
   */
  collection(path: string): MockCollectionReference;
  /**
   * Set a collection reference into a root levet of the database
   *
   * @param {MockCollectionReference} collection
   * @memberof FirestoreMocker
   */
  setCollection(collection: MockCollectionReference): void;
  /**
   * Load a collection of documents from object into database state.
   *
   * @param collectionPath collection path, all sub collectinos and documents will be autogenerated if they do not exists
   * @param collectionData an object containing a document for each field it contains.
   */
  loadCollection(collectionPath: string, collectionData: CollectionObject): void;
  /**
   * Load a single document into database state
   * @param documentPath Path into the document. All subcollections and documents will be autogenerated, if they do not exists
   * @param data Documents's data
   */
  loadDocument(documentPath: string, data: types.DocumentData): void;
  /**
   * Load project's security rules. After this, all operations are checked against actual firestore security rules
   * @param rulesFile Inmemory source code for Firebase rules to be used with tests.
   * @throws FileNotFoundError if rules are not found from given path
   */
  loadRulesFromString(rulesFile?: string): void;
  /**
   * Load project's security rules. After this, all operations are checked against actual firestore security rules
   * @param filePath File path to project's security rules. If path is not given, rules are tryed to be read from <project-root-dir>/firestore.rules -file.
   * @throws FileNotFoundError if rules are not found from given path
   */
  loadRulesFromFile(filePath?: string): void;

  /**
   * Return a root document of the whole database.
   *
   * @returns {MockDocumentReference}
   * @memberof FirestoreMocker
   */
  root(): MockDocumentReference;

  /**
   * Current rules object used in database.
   *
   * @returns {(RulesParserFacade | undefined)}
   * @memberof FirestoreMocker
   */
  rules(): FirebaseRulesIntepreter | undefined;

  /**
   * Create a context for firebase rule inquiry
   *
   * @returns {FirebaseRulesContext}
   * @memberof FirestoreMocker
   */
  getRulesContext(resource: MockDocumentReference): FirebaseRulesContext;

  /**
   * set an array of next document id to be used when creating new documents. This is used
   * to make idempotent test cased for unit tests creating a new documents. Mocker system
   * will first check from this list if there are ids to spend. If the list is empty, a new
   * random id is generated. A new calls for this method will override prior values set to an
   * array.
   *
   * @param {string[]} docIds An array of ids to be used when creating a new document
   * @memberof FirestoreMocker
   */
  setNextDocumentIds(docIds: string[]): void;

  /**
   * Will return the next document if. Method will first check, if there are ids set into
   * to list with ´setNextDocumentIds´ -method of this class, those values are used first.
   * If there are not set ids available, a new random id will be generated.
   *
   * @returns {string}
   * @memberof FirestoreMocker
   */
  getNextDocumentId(): string;
}
